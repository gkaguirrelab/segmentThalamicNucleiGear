#!/usr/bin/python3

import os, json, imageio
import matplotlib.pyplot as plt
import nibabel as nib

###################### Define the Paths and parameters ########################

# Print the CPU info
os.system('cat /proc/cpuinfo')

# Set paths and create some folders
flywheel_base ='/flywheel/v0/'
first_output_dir = '/firstOutput'
workdir = '/workdir'
final_output_dir = os.path.join(flywheel_base, 'output')
manifest_file = os.path.join(flywheel_base, 'manifest.json')
config_path = os.path.join(flywheel_base, 'config.json')
os.system('mkdir %s'%first_output_dir)
os.system('mkdir %s'%workdir)
freesurfer_environment_path = 'export FREESURFER_HOME=/freesurfer;export SUBJECTS_DIR=/freesurfer/subjects/; export PATH="$FREESURFER_HOME/bin:$PATH"; export PATH="$SUBJECTS_DIR:$PATH"'
####################### Define some functions for plotting ####################

def make_plot(subject_id, base_image, overlay, title, filename, x, y, z, apect_ratio_vector, output_folder):
    
    # This function simply gets two MRI images as inputs and overlays them 
    # using different colors for each image. Used as a diagnostic image.
        
    fig, (ax1, ax2, ax3) = plt.subplots(1,3)
    fig.suptitle(title, fontsize=20)

    epi_img = nib.load(base_image)
    epi_img_data = epi_img.get_fdata()
    ax1.imshow(epi_img_data[x,:,:], cmap="gray", aspect = apect_ratio_vector[0])
    ax2.imshow(epi_img_data[:,y,:], cmap="gray", aspect = apect_ratio_vector[1])
    ax3.imshow(epi_img_data[:,:,z], cmap="gray", aspect = apect_ratio_vector[2])
    ax1.axis('off')
    ax2.axis('off')
    ax3.axis('off')  
    
    if overlay != 'NA':
        epi_img = nib.load(overlay)
        epi_img_data = epi_img.get_fdata()
        ax1.imshow(epi_img_data[x,:,:], cmap="hot", alpha=0.4, aspect = apect_ratio_vector[3])
        ax2.imshow(epi_img_data[:,y,:], cmap="hot", alpha=0.4, aspect = apect_ratio_vector[4])
        ax3.imshow(epi_img_data[:,:,z], cmap="hot", alpha=0.4, aspect = apect_ratio_vector[5])
        ax1.axis('off')
        ax2.axis('off')
        ax3.axis('off')

    plt.savefig(os.path.join(output_folder, subject_id + '_' + filename)) 

###################Parse Config Here############################

with open(config_path) as config_file:
    job_config = json.load(config_file)
config = job_config['config']

verbose = config['verbose']

####################### Process Inputs ######################################## 

# Unzip the thalamic segmentation archive
thalamicSegmentationArchivePath = os.path.join(flywheel_base, 'input/thalamicSegmentationArchive')
thalamicSegmentationArchive = os.path.join(thalamicSegmentationArchivePath, os.listdir(thalamicSegmentationArchivePath)[0])
unzipped_folder_path = '/opt/unzipped_folder_thalamic'
os.system('mkdir %s' % unzipped_folder_path)
if verbose == '0':
    os.system('unzip -q %s -d %s' % (thalamicSegmentationArchive, unzipped_folder_path))
else:
    os.system('unzip %s -d %s' % (thalamicSegmentationArchive, unzipped_folder_path))
nu_image = os.path.join(unzipped_folder_path, 'nu.mgz')
segment = os.path.join(unzipped_folder_path, 'ThalamicNuclei.v12.T1.mgz')
segment_lowres = os.path.join(unzipped_folder_path, 'ThalamicNuclei.v12.T1.FSvoxelSpace.mgz')

# Create image temp
file_temp = '/filetemp'
os.system('mkdir %s' % file_temp)
nu_image_nifti = os.path.join(file_temp, 'nu.nii')
segment_nifti = os.path.join(file_temp, 'ThalamicNuclei.v12.T1.nii')
segment_lowres_nifti = os.path.join(file_temp, 'ThalamicNuclei.v12.T1.FSvoxelSpace.nii')

# Convert the segmentations to nifti
os.system('%s; /freesurfer/bin/mri_convert %s %s' % (freesurfer_environment_path, nu_image, nu_image_nifti))
os.system('%s; /freesurfer/bin/mri_convert %s %s' % (freesurfer_environment_path, segment, segment_nifti))
os.system('%s; /freesurfer/bin/mri_convert %s %s' % (freesurfer_environment_path, segment_lowres, segment_lowres_nifti))

# Unzip the qsiprep archive 
qsireconArchivePath = os.path.join(flywheel_base, 'input/qsireconArchive')
qsireconArchive = os.path.join(qsireconArchivePath, os.listdir(qsireconArchivePath)[0])
unzipped_folder_path_two = '/opt/unzipped_folder_qsirecon'
os.system('mkdir %s' % unzipped_folder_path_two)
if verbose == '0':
    os.system('unzip -q %s -d %s' % (qsireconArchive, unzipped_folder_path_two))
else:
    os.system('unzip %s -d %s' % (qsireconArchive, unzipped_folder_path_two))
main_qsirecon_archive = os.path.join(unzipped_folder_path_two, os.listdir(unzipped_folder_path_two)[0])
qsirecon_dir =  os.path.join(main_qsirecon_archive, os.listdir(main_qsirecon_archive)[0])

for i in os.listdir(qsirecon_dir):
    if os.path.isdir(os.path.join(qsirecon_dir, i)) == True:
        if 'sub' in i:
            fod_image = os.path.join(qsirecon_dir, i, 'ses-1', 'dwi', '%s_ses-1_space-T1w_desc-preproc_space-T1w_desc-wmFODmtnormed_msmtcsd.mif.gz' % i)
            subject_id = i[4:]


###################Run Algorithm################################
# Run fsl registration 
reg_command = ('flirt -in %s -ref %s -out %s -omat /workdir/registered0GenericAffine.mat '
               '-searchrx -180 180 -searchry -180 180 -searchrz -180 180 -dof 6' % (fod_image, nu_image,
                                                                                    '/workdir/nuRegistered.nii.gz'))
os.system(reg_command)
generic_affine = '/workdir/registered0GenericAffine.mat'
warped = '/workdir/nuRegistered.nii.gz'

# Calculate the inverse of the generic_affine 
inverse_generic_affine = '/workdir/inverseRegistered0GenericAffine.mat'
os.system('convert_xfm -omat %s -inverse %s' % (inverse_generic_affine, generic_affine))

# Apply transformations to the segmentations
os.system('flirt -in %s -ref %s -applyxfm -init %s -interp nearestneighbour -out %s' % (segment_nifti, fod_image, inverse_generic_affine, segment_nifti))
os.system('flirt -in %s -ref %s -applyxfm -init %s -interp nearestneighbour -out %s' % (segment_lowres_nifti, fod_image, inverse_generic_affine, segment_lowres_nifti))

# First save paths before zipping and mgz conversion
warped_final_save = os.path.join(first_output_dir, 'nuRegistered.mgz')
segment_nifti_final_save = os.path.join(first_output_dir, 'ThalamicNuclei.v12.T1.mgz')
segment_lowres_nifti_final_save = os.path.join(first_output_dir, 'ThalamicNuclei.v12.T1.FSvoxelSpace.mgz')

# Convert images back to mgz
os.system('%s; /freesurfer/bin/mri_convert %s %s' % (freesurfer_environment_path, warped, warped_final_save))
os.system('%s; /freesurfer/bin/mri_convert %s %s' % (freesurfer_environment_path, segment_nifti, segment_nifti_final_save))
os.system('%s; /freesurfer/bin/mri_convert %s %s' % (freesurfer_environment_path, segment_lowres_nifti, segment_lowres_nifti_final_save))

# Copy the stats folder
for file in os.path.join(unzipped_folder_path, os.listdir(unzipped_folder_path)[0]):
    path_to_file = os.path.join(os.path.join(unzipped_folder_path, os.listdir(unzipped_folder_path)[0]), file)
    if os.path.splitext(file)[1] == '.txt' or os.path.splitext(file)[1] == '.stats':
        os.system('cp %s %s/' % (path_to_file, first_output_dir))

# Get the first Tr of the FOD image for plotting
single_tr_fod = '/workdir/singlefod.nii.gz'
os.system('fslroi %s %s 0 1' % (fod_image))

# Make plots 
temp_for_images = '/tempim'
os.system('mkdir %s' % temp_for_images)
make_plot(subject_id, single_tr_fod, segment_lowres_nifti_final_save, 'Registration results', 'registrationResults.png', 131, 105, 45, [1,1,1,1,1,1], temp_for_images)

# Zip everything and output
os.system('cd %s; zip -q %s/%s_warped_segmentations.zip *' % (first_output_dir, final_output_dir, subject_id))
